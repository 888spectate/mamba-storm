- Unicode(autoreload=True) will mark the field as autoreload by default.

- Generic finds:

  foo, count = store.find((Foo, Count(Foo.name))).group_by(Foo.name)
  foo_name, count = store.find((Foo.name, Count(Foo.name))).group_by(Foo.name)

- Lazy-by-default attributes:

  class C(object):
      ...
      attr = Unicode(lazy=True)

  This would make attr be loaded only if touched.

  Or maybe lazy groups:

  class C(object):
      ...
      lazy_group = LazyGroup()
      attr = Unicode(lazy=True, lazy_group=lazy_group)

  Once one of the group attributes are accessed all of them are retrieved
  at the same time.

  Lazy groups may be integers as well:

  class C(object):
      ...
      attr = Unicode(lazy_group=1)

  lazy_group=None means not lazy.

- ReferenceSet.__contains__

- Implement ResultSet.reverse[d]() to invert order_by()?

- Union, intersection, ... as:

  result3 = result1.union(result2)

- Add support to cyclic references.

- Implement support for negative caches to tell when an object
  isn't available.

- Implement support for complex removes and updates with Exists().

- Log SQL statements and Store actions.

- Support for quoted strings.

- Option to keep object in cache until explicitly removed.

- Implement store.copy()

- Implement must_define in properties.

- Implement slicing ([:]) in BoundReferenceSet

- Handle $foo$bar$foo$ literals

- Could Reference(Set)s include a "where" clause? Readonly perhaps?

- Make the primary key in __table__ be optional. If it's not provided
  the object isn't cached and updates aren't tracked.

- Between()

- Automatic class generation, perhaps based on Django's inspectdb:

  http://www.djangoproject.com/documentation/legacy_databases/
  http://www.djangoproject.com/documentation/django_admin/

- Support allow_microseconds=False in DateTime properties/variables.

- Support allow_self in Reference and ReferenceSet, and default
  to false.
