- Make this work: [DONE]

  person, company = store.find((Person, Company),
                               Person.company_id == Company.id).one()

- Generic SQL() expression [DONE]

- Join support [DONE]

- Disable distinct by default and add support for config(distinct=True) [DONE]

- Aliases [DONE]

  ClassAlias = Alias(Class)
  store.find(Class, ClassAlias.name == ...)
  
- Lazy expressions [DONE]

  package.group_id = SQL("get_group_id('name')")
  print package.group_id # Flush and get the real id.

- Generic finds:

  foo, count = store.find((Foo, Count(Foo.name))).group_by(Foo.name)
  foo_name, count = store.find((Foo.name, Count(Foo.name))).group_by(Foo.name)

- Lazy-by-default attributes:

  class C(object):
      ...
      attr = Unicode(lazy=True)

  This would make attr be loaded only if touched.

  Or maybe lazy groups:

  class C(object):
      ...
      lazy_group = LazyGroup()
      attr = Unicode(lazy=True, lazy_group=lazy_group)

  Once one of the group attributes are accessed all of them are retrieved
  at the same time.

  Lazy groups may be integers as well:

  class C(object):
      ...
      attr = Unicode(lazy_group=1)

  lazy_group=None means not lazy.

- not Column => NOT column

- Column.name.like/lower/startswith/endswith/...

- Reference.__contains__

- Fix Column.is_in() to support non-list arguments (such as SQL(), or Select())

- Implement ResultSet.reverse[d]() to invert order_by()?

- Union, intersection, ... as:

  result3 = result1.union(result2)

- Fix modification of PickleVariables
- Add support to cyclic references.
- Implement support for negative caches to tell when an object
  isn't available.
- Implement support for complex removes and updates with Exists().
- Log SQL statements and Store actions.
- Support for quoted strings.
- Make Column() == True become "COLUMN IS TRUE".
- Option to keep object in cache until explicitly removed.
- Implement store.copy()
- Implement must_define in properties.
- Implement ranges ([:]) in ResultSet and ReferenceSetProxy
- Implement (B)PickleKind
- Handle reference loops.
- Handle $foo$bar$foo$ literals
- Could Reference(Set)s include a "where" clause? Readonly perhaps?
- Implement reference comparisons (Foo.ref == obj)
- Make the primary key in __table__ be optional. If it's not provided
  the object isn't cached and updates aren't tracked.
- Add support for deferred class/attribute definition on references.
- Between()

- Automatic class generation, perhaps based on Django's inspectdb:

  http://www.djangoproject.com/documentation/legacy_databases/
  http://www.djangoproject.com/documentation/django_admin/

